# ЛР 3. HA Postgres Cluster

**Задача:**
Развернуть и настроить высокодоступный кластер Postgres.

## Часть 1. Поднимаем Postgres

1. Создали директорию проекта, зашли в нее через Powershell, и создали там dockerfile.
2. Создали compose файл.
3. Создали postgres0.yml и postgres1.eml файлы.
4. Задеплоили

![image](media/4f280952-ab9b-47f3-beba-c2863e93ed5e%20(1).jfif)
![image](media/4f280952-ab9b-47f3-beba-c2863e93ed5e%20(1).jfif)
![image](media/1c350cdc-2ddc-4a9a-ba2b-6afc0ac28dd3.jfif)
![image](media/91f14a0d-aadb-44df-a2b9-e22f0eebfede.jfif)
![image](media/4c7090cd-3ce8-4d5c-b418-f5eab2cc3d14.jfif)
![image](media/c2030d7e-d5bd-4b8b-81b3-62f42e8c1e9b.jfif)

## Часть 2. Проверяем репликацию

Для упрощения дальнейших проверок и избежания проблем с фаерволом при внешних
подключениях, мы перенесли всю лабораторную на виртуальную машину. Пришлось установить
docker и docker-compose, но ничего не поменялось. Мы заново произвели

```bash
docker-compose up -d
docker-compose ps 
```

По итогу мы получили 3 работающих контейнера. Далее мы подключились к master и slave
базам данных и проверили репликацию и доступ к записи.

**Созданная таблица реплицировалась с мастера на слэйв и унаследовала вставленные данные**

![photo_2024-12-11 15.19.01.jpeg](media/photo_2024-12-11%2015.19.01.jpeg)

**pg-slave выдает ошибку при попытке записи данных**
![photo_2024-12-11 15.19.02.jpeg](media/photo_2024-12-11%2015.19.02.jpeg)

## Часть 3. Делаем среднего роста высокую доступность

Мы добавили в `docker-compose.yml` блок для haproxy, который сел на (традиционный для
бд) порт 5432. Далее мы создали конфиг файл (занятно, что он не работал, пока мы не
добавили новую пустую строку в конце файла) и перезапустили docker-compose. При
подключении я создал новую таблицу, заполнил ее и проверил репликацию на обоих узлах.

**Таблица отображается на всех 3 подключениях**

![photo_2024-12-11 15.19.03.jpeg](media/photo_2024-12-11%2015.19.03.jpeg)

**Внесли и прочитали данные из таблицы**

![photo_2024-12-11 15.19.06.jpeg](media/photo_2024-12-11%2015.19.06.jpeg)

![photo_2024-12-11 15.19.04.jpeg](media/photo_2024-12-11%2015.19.04.jpeg)


Все конфигурационные файлы можно посмотреть в папке files, это копия файлов с 
удаленного сервера. 

## Задание

Любым способом выключаем доступ до ноды, которая сейчас является мастером (например, через docker stop). Некоторое время ждем, после этого анализируем логи и так же пытаемся считать/записать что-то в БД через entrypoint подключение. Затем необходимо расписать, получилось или нет, а так же объяснить, что в итоге произошло после принудительного выключения мастера (со скриншотами)

![image](https://github.com/user-attachments/assets/2425b053-d332-4475-9615-e3a86f56ffce)
Отключение мастер ноды 

![image](https://github.com/user-attachments/assets/966a3272-f74b-467f-bcc7-fa8f5cc8566d)

![image](https://github.com/user-attachments/assets/b43c6cca-bade-4edc-8ecb-f453171d15d8)

Команда - docker exec -it pg-slave patronictl -c /postgres1.yml list
![image](https://github.com/user-attachments/assets/c7d16222-d773-4fba-a6f8-9ad7ba070812)

Команда - docker stop pg-master

pg-master

Команда - docker exec -it pg-slave patronictl -c /postgres1.yml list
![image](https://github.com/user-attachments/assets/dbb1d814-de5e-44c8-a5b4-eb1adab4284c)

![image](https://github.com/user-attachments/assets/5cc4f8f4-5f23-4696-9466-72dc3841ab93)

Слейв нода теперь имеет роль мастера.

В докерфайлы была добавлена строка 

![image](https://github.com/user-attachments/assets/a4a05779-ce61-4658-b61f-40247b2f5807)

## Ответы на вопросы:

1) *Порты 8008 и 5432 вынесены в разные директивы, expose и ports. По сути, если записать
   8008 в ports, то он тоже станет exposed. В
   чем разница?*

- Порты, вынесенные в expose, доступны только для других контейнеров, а вынесенные в
  ports доступны извне.

2) *При обычном перезапуске композ-проекта, будет ли сбилден заново образ? А если
   предварительно отредактировать файлы
   postgresX.yml? А если содержимое самого Dockerfile? Почему?*

- Нет, во всех случаях образ не будет сбилден заново, потому что образы в docker
  кэшируются для оптимизации.
  
